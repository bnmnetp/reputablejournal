<p>I have been writing programs since I was in 9th grade, that would be
35 years (Yikes!) &nbsp;I have more than put in my 10,000 hours to attain
some level of mastery, but&nbsp;I like to think of it as wisdom. &nbsp;Studies
have shown that there can be huge differences in the ability level of
even the most experienced coders. &nbsp;More than a factor of 20, in some
cases! I think beginning and intermediate CS students really struggle
with this.  They see some of their classmates streaking on ahead of
them effortlessly writing lines and lines of code.  But for them its
a constant struggle.  I've watched some of my students really struggling
with the latest homework assignment, and I felt compelled to write down
some &quot;words of wisdom&quot; to try and help them through the rest of the semester.</p>
<p>I have been lucky enough to work with some of the best developers in the world
during my career.  &nbsp;Here is a summary of &nbsp;some tips and things that I have
observed. &nbsp;I practice all of these things in my own development work, and you
should too. &nbsp;In my opinion there is no more valuable advice than the
first section on Incremental Development.&nbsp;But, I would love to hear
from friends, and former students.  What tips would you give beginning
to intermediate students on writing software?</p>
<!-- TEASER_END -->
<div class="section" id="incremental-development">
<h1>Incremental Development</h1>
<ol class="arabic simple">
<li><strong>Think before you code</strong>. &nbsp;Before you sit down and start coding, try
drawing a picture that illustrates your objects, and the
relationships between those objects. &nbsp;Its important to understand not
only the basic functionality of each object, but how they interact.</li>
<li><strong>Make a plan</strong>. &nbsp;After you have an idea of the big picture now make
a plan for what you want to do first, second, etc. &nbsp;Nothing is more
satisfying than knowing you have been productive. &nbsp;I have known CEOs
of companies that delight in creating a hand-written todo list each
morning, for no other reason than crossing something off the list
gives them a little boost of joy and keeps them going through the
day. &nbsp;Everyone likes that feeling of being productive. &nbsp;Making
progress on your plan makes you feel productive, and motivates you to
keep going.</li>
<li><strong>Start Small</strong>. &nbsp;Start with a small class, for example die, and
write a little test program to make sure that the die class is
working properly.</li>
<li><strong>Test as you go</strong>. &nbsp;Nothing frees you up to work on the next thing,
like knowing you can build on something you have already completed.
&nbsp;Doing a good job of testing is what gives you that freedom. &nbsp;I know,
it is tempting, to look at a small class and read the code and simply
assume that it works. &nbsp;Most of the time this is a bad assumption,
even in simple examples.</li>
<li><strong>Use Stubs.</strong> &nbsp;Even in a relatively small class it is tempting to
try to implement all of the methods and then compile. &nbsp;This may not
be a very good idea. &nbsp; What you can do is write a stub for each
class. &nbsp;For example if you have a method for your cup called shake,
and you are not ready to write everything in shake just make a
function called shake with an empty body. &nbsp;This will compile fine,
but it won't do anything. &nbsp;If your method is supposed to return a
value, you may need to have it return some bogus value for the time
being.</li>
<li><strong>Build on success</strong>. &nbsp;Once you have one class working then go on to
the next. &nbsp;Test that class, and test its interaction with the class
or classes that came before it.</li>
<li>If you still have classes to write GOTO 3</li>
<li>Integrate your classes and write your main, but again, <strong>start
small</strong>. &nbsp;Don't try to add everything at once. &nbsp;For example in the
Yahtzee command line game, start with the roll command and make sure
you can roll all of your dice. &nbsp;Then add each command one at a time.</li>
<li><strong>Always keep a working program working.</strong> &nbsp;Notice that if you use
this approach you always have something that compiles and runs that
you can hand in. &nbsp;Even a simple example program of a die class with a
die that you can roll is worth more points that nothing at all, or a
program that simply does not compile.</li>
</ol>
</div>
<div class="section" id="use-the-tools">
<h1>Use The Tools</h1>
<ol class="arabic simple">
<li>Early on in the development, you should create a directory for this
project. &nbsp;This keeps everything together and reduces the clutter.</li>
<li>Use git. &nbsp;-- Start right away with a git init in your directory, and
commit your changes often. &nbsp; This always gives you a road back.</li>
<li>Use a Makefile</li>
<li>When debugging, make sure you sprinkle in plenty of cout statements.
&nbsp;If you are getting unexpected seg faults, use gdb to find out where
the program is crashing.</li>
<li>For goodness sake, use the internet. &nbsp;Stackoverflow is your friend.
cplusplus.com is your friend, &nbsp;You should <strong>not</strong> feel like you ought
to have command of everything off the top of your head. &nbsp;Maybe after
several years of C++ programming you will have all of the options
memorized, but until then, use the documentation. &nbsp;Even googling
large parts of a compiler error message may lead you to a solution.</li>
</ol>
</div>
<div class="section" id="debugging">
<h1>Debugging</h1>
<ol class="arabic simple">
<li><strong>Talk it out.</strong>  Either to yourself, or even better, to someone else
The number of times that I sit in my office and simply ask a student
to explain their code to me is amazing.  Very often, while that
explanation is in progress a lightbulb goes on, and the student
sees the problem.  I wish it was because of my mystical professorial
powers, but more often than not it is by telling someone else that
we are forced to...</li>
<li><strong>Confront your assumptions.</strong>   Way too often we are conviced our
code is correct because we don't see what we actually wrote.  In most
cases we see what we think we wrote.  By explaining to someone else
we are forced to see what we actually put in the file.  In some
extreme cases I find that students are convinced that there must
be some other evil force in the universe that is causing their
program to fail, becuase they have done everything right.  This
has never been the case yet.  The programs that we write for class
are not going to be the programs that find new bugs in the C++ compiler
or the Python programming language.</li>
<li>Sometimes you just can't beat good old fashioned <strong>pen and paper style
tracing.</strong> In this world of fast turnarounds, instant compiles, and fancy IDE's
we too often get caught up in making quick changes to the program just
to see if that fixes the problem.  Usually this is just masking some
logic error or assumption we are making.  Pen and paper style tracing
is another way to force our minds into focusing on what is there
instead of what we assume is there.</li>
</ol>
</div>
<div class="section" id="those-pesky-compiler-errors">
<h1>Those Pesky Compiler Errors</h1>
<ol class="arabic simple">
<li>Yes, C++ error messages are voluminous, cryptic, and downright
frustrating in many cases!! &nbsp;There's nothing you can do about that.
except:</li>
<li>Did I mention you should start small. &nbsp;If you write your code in
small chunks, and compile frequently this will reduce the number of
compiler errors, and will help you focus on where the error is likely
to be.. <em>Hint</em>: &nbsp;in the new stuff you have just written.</li>
<li><strong>Be systematic.</strong>  If the code compiled two minutes ago, and you have
just added three new lines of code, and now it does not compile you
should have a pretty good idea of where the error was introduced.</li>
<li><strong>Start with the first error!!</strong> &nbsp; Its tempting to look at the error
message at the end of the list. because thats what you see as soon as
the compiler is done. &nbsp;But, scroll back and start with the first one.
&nbsp;Many of the errors later on are the result of an error at the start.
&nbsp;If you focus on fixing the wrong error, you are likely wasting your
time.</li>
<li><strong>Pay attention to the parameters and their Types</strong>. &nbsp; Very often the
questions I get boil down to the fact that someone is trying to call
a function but is passing a parameter of the wrong type. &nbsp;Some words
and phrases to pay attention to that may help you identify these
errors: &nbsp;&nbsp;&quot;candidate function not viable&quot; , &nbsp;&quot;no known conversion
from &nbsp;XXXX to YYY&quot;</li>
<li><strong>Use redirection!</strong> &nbsp;Sometimes its hard to find the first error.
&nbsp;You can change your compile command, or run it manually and send the
output to a file. &nbsp;For example: g++ -c cup.cpp &gt; compile.out 2&gt;&amp;1</li>
<li>Sometimes the best way back is to comment some things out. &nbsp;If you
have followed the <strong>start small</strong> philosophy this should not be an
issue. &nbsp;But maybe you didn't and now you have a big pile of code that
doesn't compile. &nbsp;Once again you need to break it up some how.
&nbsp;Sometimes the way to do this is to comment out a big chunk of your
code and see if the error goes away.</li>
</ol>
</div>
<div class="section" id="dealing-with-complexity">
<h1>Dealing with Complexity</h1>
<ol class="arabic simple">
<li>There is no doubt that the programs we write in this class are more
complicated than any you have ever written. &nbsp;Often by an order of
magnitude or two. &nbsp;This can feel overwhelming, and is yet another
reason for you to go back and reread the first section of this
document again.</li>
<li><strong>Embrace Abstraction.</strong> At the time you are creating a die class you
may feel its a waste of time. &nbsp;Why not just a variable that we assign
a random number to? &nbsp;Or the cup class, why not just use a vector?
&nbsp;But as the project progresses you will see that using the
abstraction has some &nbsp;huge benefits:<ol class="arabic">
<li>It makes the interesting parts of your code much more readable.</li>
<li>It reduces the amount of repetition you need to do.</li>
<li>If you follow good practice, it gives you confidence that the
little things in your program are working correctly.</li>
</ol>
</li>
<li>Learn and embrace the KISS (keep it simple stupid) principle.  Too
often I see people making things way harder than they need to be.
You don't have to reinvent the wheel for every assignment.  Learn
to reuse code from previous assignments.</li>
<li>Part of dealing with complexity is having some confidence that what
you have done is correct. &nbsp;Working in small chunks, and testing in
small chunks helps you develop that confidence.</li>
<li>The tools we have talked about in this class are there to help you
deal with complexity. &nbsp;Make, gdb, grep, and others are there to make
your life better.</li>
<li>Don't worry if you feel like you don't know everything. &nbsp;having
knowledge available to you comes after time, and frequent practice.
&nbsp;You are not going to be there after one semester.</li>
</ol>
</div>
